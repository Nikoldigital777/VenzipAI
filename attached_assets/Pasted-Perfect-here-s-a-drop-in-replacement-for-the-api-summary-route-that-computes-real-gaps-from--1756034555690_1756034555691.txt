Perfect—here’s a **drop-in replacement** for the `/api/summary` route that computes real gaps from `compliance_tasks` and `risks` (open **high/critical** items only) and returns a data-driven panel.

### 1) Update imports (top of `server/routes.ts`)

Make sure you already import these tables (add if missing):

```ts
import { complianceTasks, risks as risksTable, chatMessages, evidenceDocuments, auditLogs } from "../shared/schema";
import { and, ne, inArray, desc, eq, sql } from "drizzle-orm";
```

### 2) Replace the existing `/api/summary` handler

Paste this **entire** handler in place of your current one:

```ts
// --- Dashboard summary (data-driven gaps from tasks + risks) ---
router.get("/api/summary", async (_req, res) => {
  try {
    // --- base stats
    const [{ count: uploadsCount }] = await db.execute<{ count: number }>(
      sql`SELECT COUNT(*)::int AS count FROM ${evidenceDocuments}`
    );
    const [{ count: chatsCount }] = await db.execute<{ count: number }>(
      sql`SELECT COUNT(*)::int AS count FROM ${chatMessages}`
    );

    const recentActivity = await db
      .select()
      .from(auditLogs)
      .orderBy(desc(auditLogs.createdAt))
      .limit(8);

    // --- gaps = open high/critical tasks + high/critical risks
    // Tasks: not done AND priority in ('high','critical')
    const highTasks = await db
      .select()
      .from(complianceTasks)
      .where(
        and(
          ne(complianceTasks.status, "done"),
          inArray(complianceTasks.priority, ["high", "critical"])
        )
      )
      .orderBy(
        // critical first, then nearest due date, then latest update
        desc(sql`CASE ${complianceTasks.priority} WHEN 'critical' THEN 2 WHEN 'high' THEN 1 ELSE 0 END`),
        sql`${complianceTasks.dueDate} NULLS LAST`,
        desc(complianceTasks.updatedAt)
      )
      .limit(10);

    // Risks: severity in ('high','critical')
    const highRisks = await db
      .select()
      .from(risksTable)
      .where(inArray(risksTable.severity, ["high", "critical"]))
      .orderBy(
        desc(sql`CASE ${risksTable.severity} WHEN 'critical' THEN 2 WHEN 'high' THEN 1 ELSE 0 END`),
        desc(risksTable.updatedAt)
      )
      .limit(10);

    // Normalize both into one "gaps" list for the UI
    const gaps = [
      ...highTasks.map((t) => ({
        id: `task-${t.id}`,
        kind: "task" as const,
        title: t.title,
        severity: t.priority === "critical" ? "critical" : "high",
        meta: {
          framework: t.framework,
          status: t.status,
          dueDate: t.dueDate,
        },
      })),
      ...highRisks.map((r) => ({
        id: `risk-${r.id}`,
        kind: "risk" as const,
        title: r.title,
        severity: r.severity, // 'high' | 'critical'
        meta: {
          category: r.category,
          probability: r.probability,
        },
      })),
    ];

    // --- simple, explainable compliance score
    // Start with baseline + "activity" bonus, then subtract weighted gap penalties
    const baseline = 45;
    const bonus = Math.min(35, uploadsCount * 2 + Math.floor(chatsCount / 3));

    const highTaskCount = highTasks.filter((t) => t.priority === "high").length;
    const critTaskCount = highTasks.filter((t) => t.priority === "critical").length;
    const highRiskCount = highRisks.filter((r) => r.severity === "high").length;
    const critRiskCount = highRisks.filter((r) => r.severity === "critical").length;

    // Heavier penalty for critical risks than critical tasks
    const penalty =
      highTaskCount * 2 +
      critTaskCount * 4 +
      highRiskCount * 3 +
      critRiskCount * 6;

    const compliancePercent = Math.max(0, Math.min(98, baseline + bonus - penalty));

    res.json({
      compliancePercent,
      gaps, // array of { id, kind: 'task'|'risk', title, severity, meta: {...} }
      stats: {
        uploads: uploadsCount,
        conversations: chatsCount,
        tasksOpenHigh: highTaskCount + critTaskCount,
        risksHigh: highRiskCount + critRiskCount,
      },
      recentActivity: recentActivity.map((a) => ({
        id: a.id,
        action: a.action,
        resourceType: a.resourceType,
        createdAt: a.createdAt,
      })),
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});
```

### 3) Optional: enrich the Dashboard “Top gaps” UI

If you want to surface **kind** and **meta** in the list (already returned above), tweak the item render in your `Dashboard` page from:

```tsx
<div className="font-medium">{g.title}</div>
```

to:

```tsx
<div className="font-medium">
  {g.title}
  <span className="ml-2 text-xs text-gray-500">
    {g.kind === "task" ? `(${g.meta?.framework ?? "task"})` : `(${g.meta?.category ?? "risk"})`}
  </span>
</div>
```

…and you can also badge **critical** distinctly by adjusting the class logic:

```tsx
g.severity === "critical"
  ? "bg-red-500/15 text-red-600"
  : g.severity === "high"
  ? "bg-amber-500/15 text-amber-600"
  : "bg-success-green/20 text-success-green"
```

---

That’s it. After restarting the server, your **Dashboard** will reflect live counts, and the **gaps** panel will be driven by real, high-impact work left to do across Tasks and Risks.
