// server/routes/tasks.ts
import { Router } from "express";
import { db } from "../db";
import { tasks, taskComments, taskAttachments, users, frameworks, companies } from "@shared/schema";
import { eq, and, or, like, desc, asc, inArray, isNotNull } from "drizzle-orm";
import { isAuthenticated } from "../replitAuth";
import { z } from "zod";

const router = Router();

// Validation schemas
const createTaskSchema = z.object({
  title: z.string().min(1).max(500),
  description: z.string().optional(),
  category: z.enum(['policy', 'procedure', 'training', 'audit', 'risk_assessment', 'documentation', 'technical', 'other']),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  frameworkId: z.string().uuid(),
  assignedToId: z.string().uuid().optional(),
  dueDate: z.string().datetime().optional(),
  startDate: z.string().datetime().optional(),
  estimatedHours: z.number().int().positive().optional(),
  complianceRequirement: z.string().optional(),
  evidenceRequired: z.boolean().optional(),
  tags: z.array(z.string()).optional()
});

const updateTaskSchema = createTaskSchema.partial().extend({
  status: z.enum(['not_started', 'in_progress', 'under_review', 'completed', 'blocked']).optional(),
  progressPercentage: z.number().int().min(0).max(100).optional(),
  actualHours: z.number().int().positive().optional(),
  blockedReason: z.string().optional(),
  completedAt: z.string().datetime().optional()
});

const taskFilterSchema = z.object({
  status: z.enum(['not_started', 'in_progress', 'under_review', 'completed', 'blocked']).optional(),
  priority: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  category: z.enum(['policy', 'procedure', 'training', 'audit', 'risk_assessment', 'documentation', 'technical', 'other']).optional(),
  frameworkId: z.string().uuid().optional(),
  assignedToId: z.string().uuid().optional(),
  overdue: z.boolean().optional(),
  search: z.string().optional(),
  sortBy: z.enum(['dueDate', 'priority', 'status', 'createdAt', 'title']).default('dueDate'),
  sortOrder: z.enum(['asc', 'desc']).default('asc'),
  limit: z.number().int().positive().max(100).default(20),
  offset: z.number().int().min(0).default(0)
});

// Get user's company ID helper
async function getUserCompanyId(userId: string): Promise<string | null> {
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: { company: true }
  });
  return user?.company?.id || null;
}

// GET /api/tasks - List tasks with filtering and search
router.get("/", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const filters = taskFilterSchema.parse(req.query);
    
    // Build WHERE conditions
    const conditions = [eq(tasks.companyId, companyId)];
    
    if (filters.status) {
      conditions.push(eq(tasks.status, filters.status));
    }
    
    if (filters.priority) {
      conditions.push(eq(tasks.priority, filters.priority));
    }
    
    if (filters.category) {
      conditions.push(eq(tasks.category, filters.category));
    }
    
    if (filters.frameworkId) {
      conditions.push(eq(tasks.frameworkId, filters.frameworkId));
    }
    
    if (filters.assignedToId) {
      conditions.push(eq(tasks.assignedToId, filters.assignedToId));
    }
    
    if (filters.overdue) {
      conditions.push(
        and(
          isNotNull(tasks.dueDate),
          // dueDate < now() and status != completed
          eq(tasks.status, 'completed') // This would be inverted in real SQL
        )
      );
    }

    let query = db
      .select({
        id: tasks.id,
        title: tasks.title,
        description: tasks.description,
        category: tasks.category,
        priority: tasks.priority,
        status: tasks.status,
        dueDate: tasks.dueDate,
        startDate: tasks.startDate,
        completedAt: tasks.completedAt,
        estimatedHours: tasks.estimatedHours,
        actualHours: tasks.actualHours,
        progressPercentage: tasks.progressPercentage,
        complianceRequirement: tasks.complianceRequirement,
        evidenceRequired: tasks.evidenceRequired,
        blockedReason: tasks.blockedReason,
        tags: tasks.tags,
        createdAt: tasks.createdAt,
        updatedAt: tasks.updatedAt,
        framework: {
          id: frameworks.id,
          name: frameworks.name,
          displayName: frameworks.displayName
        },
        assignedTo: {
          id: users.id,
          firstName: users.firstName,
          lastName: users.lastName,
          email: users.email
        }
      })
      .from(tasks)
      .leftJoin(frameworks, eq(tasks.frameworkId, frameworks.id))
      .leftJoin(users, eq(tasks.assignedToId, users.id))
      .where(and(...conditions));

    // Add search functionality
    if (filters.search) {
      query = query.where(
        or(
          like(tasks.title, `%${filters.search}%`),
          like(tasks.description, `%${filters.search}%`),
          like(tasks.complianceRequirement, `%${filters.search}%`)
        )
      );
    }

    // Add sorting
    const sortColumn = {
      dueDate: tasks.dueDate,
      priority: tasks.priority,
      status: tasks.status,
      createdAt: tasks.createdAt,
      title: tasks.title
    }[filters.sortBy];

    query = query.orderBy(
      filters.sortOrder === 'desc' ? desc(sortColumn) : asc(sortColumn)
    );

    // Add pagination
    query = query.limit(filters.limit).offset(filters.offset);

    const results = await query;
    
    // Get total count for pagination
    const totalCount = await db
      .select({ count: tasks.id })
      .from(tasks)
      .where(and(...conditions));

    // Parse JSON fields
    const formattedResults = results.map(task => ({
      ...task,
      tags: task.tags ? JSON.parse(task.tags) : []
    }));

    res.json({
      tasks: formattedResults,
      pagination: {
        total: totalCount.length,
        limit: filters.limit,
        offset: filters.offset,
        hasMore: totalCount.length > filters.offset + filters.limit
      }
    });

  } catch (error) {
    console.error("Error fetching tasks:", error);
    res.status(500).json({ message: "Failed to fetch tasks" });
  }
});

// POST /api/tasks - Create new task
router.post("/", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const taskData = createTaskSchema.parse(req.body);
    
    const newTask = await db
      .insert(tasks)
      .values({
        ...taskData,
        companyId,
        createdById: user.claims.sub,
        tags: taskData.tags ? JSON.stringify(taskData.tags) : null,
        dueDate: taskData.dueDate ? new Date(taskData.dueDate) : null,
        startDate: taskData.startDate ? new Date(taskData.startDate) : null
      })
      .returning();

    res.status(201).json(newTask[0]);

  } catch (error) {
    console.error("Error creating task:", error);
    res.status(500).json({ message: "Failed to create task" });
  }
});

// GET /api/tasks/:id - Get specific task
router.get("/:id", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    const { id } = req.params;
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const task = await db.query.tasks.findFirst({
      where: and(eq(tasks.id, id), eq(tasks.companyId, companyId)),
      with: {
        framework: true,
        assignedTo: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        createdBy: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        comments: {
          with: {
            user: {
              columns: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            }
          },
          orderBy: [desc(taskComments.createdAt)]
        },
        attachments: {
          with: {
            document: true
          }
        }
      }
    });

    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }

    // Parse JSON fields
    const formattedTask = {
      ...task,
      tags: task.tags ? JSON.parse(task.tags) : [],
      dependencies: task.dependencies ? JSON.parse(task.dependencies) : []
    };

    res.json(formattedTask);

  } catch (error) {
    console.error("Error fetching task:", error);
    res.status(500).json({ message: "Failed to fetch task" });
  }
});

// PUT /api/tasks/:id - Update task
router.put("/:id", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    const { id } = req.params;
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const updates = updateTaskSchema.parse(req.body);
    
    // Check if task exists and belongs to user's company
    const existingTask = await db.query.tasks.findFirst({
      where: and(eq(tasks.id, id), eq(tasks.companyId, companyId))
    });

    if (!existingTask) {
      return res.status(404).json({ message: "Task not found" });
    }

    // Handle completion
    if (updates.status === 'completed' && existingTask.status !== 'completed') {
      updates.completedAt = new Date().toISOString();
      updates.progressPercentage = 100;
    }

    const updatedTask = await db
      .update(tasks)
      .set({
        ...updates,
        tags: updates.tags ? JSON.stringify(updates.tags) : undefined,
        dueDate: updates.dueDate ? new Date(updates.dueDate) : undefined,
        startDate: updates.startDate ? new Date(updates.startDate) : undefined,
        completedAt: updates.completedAt ? new Date(updates.completedAt) : undefined,
        updatedAt: new Date()
      })
      .where(eq(tasks.id, id))
      .returning();

    res.json(updatedTask[0]);

  } catch (error) {
    console.error("Error updating task:", error);
    res.status(500).json({ message: "Failed to update task" });
  }
});

// DELETE /api/tasks/:id - Delete task
router.delete("/:id", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    const { id } = req.params;
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Check if task exists and belongs to user's company
    const existingTask = await db.query.tasks.findFirst({
      where: and(eq(tasks.id, id), eq(tasks.companyId, companyId))
    });

    if (!existingTask) {
      return res.status(404).json({ message: "Task not found" });
    }

    await db.delete(tasks).where(eq(tasks.id, id));
    
    res.status(204).send();

  } catch (error) {
    console.error("Error deleting task:", error);
    res.status(500).json({ message: "Failed to delete task" });
  }
});

// PATCH /api/tasks/:id/complete - Mark task as complete
router.patch("/:id/complete", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    const { id } = req.params;
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const updatedTask = await db
      .update(tasks)
      .set({
        status: 'completed',
        progressPercentage: 100,
        completedAt: new Date(),
        updatedAt: new Date()
      })
      .where(and(eq(tasks.id, id), eq(tasks.companyId, companyId)))
      .returning();

    if (updatedTask.length === 0) {
      return res.status(404).json({ message: "Task not found" });
    }

    res.json(updatedTask[0]);

  } catch (error) {
    console.error("Error completing task:", error);
    res.status(500).json({ message: "Failed to complete task" });
  }
});

// POST /api/tasks/:id/comments - Add comment to task
router.post("/:id/comments", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    const { id } = req.params;
    const { comment } = req.body;
    
    if (!companyId || !comment?.trim()) {
      return res.status(400).json({ message: "Invalid request" });
    }

    // Verify task exists and belongs to company
    const task = await db.query.tasks.findFirst({
      where: and(eq(tasks.id, id), eq(tasks.companyId, companyId))
    });

    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }

    const newComment = await db
      .insert(taskComments)
      .values({
        taskId: id,
        userId: user.claims.sub,
        comment: comment.trim()
      })
      .returning();

    res.status(201).json(newComment[0]);

  } catch (error) {
    console.error("Error adding comment:", error);
    res.status(500).json({ message: "Failed to add comment" });
  }
});

// GET /api/tasks/stats - Get task statistics
router.get("/stats/overview", isAuthenticated, async (req, res) => {
  try {
    const user = req.user as any;
    const companyId = await getUserCompanyId(user.claims.sub);
    
    if (!companyId) {
      return res.status(404).json({ message: "Company not found" });
    }

    const stats = await db
      .select({
        status: tasks.status,
        priority: tasks.priority,
        count: tasks.id
      })
      .from(tasks)
      .where(eq(tasks.companyId, companyId))
      .groupBy(tasks.status, tasks.priority);

    // Format stats for easier consumption
    const formattedStats = {
      byStatus: {},
      byPriority: {},
      total: 0
    };

    stats.forEach(stat => {
      formattedStats.byStatus[stat.status] = (formattedStats.byStatus[stat.status] || 0) + 1;
      formattedStats.byPriority[stat.priority] = (formattedStats.byPriority[stat.priority] || 0) + 1;
      formattedStats.total += 1;
    });

    res.json(formattedStats);

  } catch (error) {
    console.error("Error fetching task stats:", error);
    res.status(500).json({ message: "Failed to fetch task statistics" });
  }
});

export default router;