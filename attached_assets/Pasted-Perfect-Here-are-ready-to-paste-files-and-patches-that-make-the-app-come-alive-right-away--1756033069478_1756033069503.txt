Perfect. Here are **ready-to-paste** files and patches that make the app “come alive” right away:

* **Drizzle schema** (forms the data spine; includes `chat_messages` and `evidence_documents`)
* **Claude chat endpoints**: `POST /api/chat` and `GET /api/chat/messages`
* **Upload route**: `POST /api/documents/upload` with Multer
* **Dashboard summary**: `GET /api/summary`

I aligned names and paths with your repo so you can copy these in place and run. I also included tiny fallbacks so things work even if Claude isn’t configured yet.

> Why these paths? Your chat widget calls `/api/chat` and `/api/chat/messages?limit=20` already, so we implement those as-is . The UI shell and pages are already registered in the client router, so we only need to provide the data these screens expect via new API routes .

---

# 1) Replace `shared/schema.ts`

```ts
// shared/schema.ts
import {
  pgTable, uuid, varchar, integer, timestamp, jsonb, boolean, text, pgEnum
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

// --- Enums ---
export const messageTypeEnum = pgEnum("message_type", ["user", "assistant"]);

// --- Users & Companies (MVP-light; expand later if you want) ---
export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  companyName: varchar("company_name", { length: 255 }),
  role: varchar("role", { length: 64 }),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
});

export const companies = pgTable("companies", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: varchar("name", { length: 255 }).notNull(),
  industry: varchar("industry", { length: 128 }),
  size: varchar("size", { length: 64 }), // e.g., "1-10"
  frameworksSelected: jsonb("frameworks_selected").$type<string[] | null>(),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
});

// --- Chat (backs /api/chat & /api/chat/messages) ---
export const chatMessages = pgTable("chat_messages", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id"),
  message: text("message").notNull(),
  messageType: messageTypeEnum("message_type").notNull(),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
});

// --- Evidence / Documents (backs upload route) ---
export const evidenceDocuments = pgTable("evidence_documents", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id"),
  filename: varchar("filename", { length: 512 }).notNull(),
  mimetype: varchar("mimetype", { length: 128 }).notNull(),
  size: integer("size").notNull(),
  storagePath: varchar("storage_path", { length: 1024 }).notNull(),
  sha256: varchar("sha256", { length: 64 }),
  version: integer("version").default(1).notNull(),
  aiAnalysis: jsonb("ai_analysis"),
  uploadedAt: timestamp("uploaded_at", { withTimezone: false }).defaultNow().notNull(),
});

// --- Minimal audit log (nice for recent activity feed) ---
export const auditLogs = pgTable("audit_logs", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id"),
  action: varchar("action", { length: 128 }).notNull(), // "upload", "chat", etc.
  resourceType: varchar("resource_type", { length: 64 }),
  resourceId: uuid("resource_id"),
  detail: jsonb("detail"),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
});

// --- Convenience seeds (optional) ---
// You can call this SQL in a one-off migration to seed frameworks if you decide to add a table.
export const seedFrameworksSql = sql`
-- Example seed if/when you add a frameworks table later.
-- INSERT INTO frameworks (id, name, description, requirements_json, version) VALUES (...);
`;
```

---

# 2) `server/anthropic.ts` (minimal helper)

> Uses env `ANTHROPIC_API_KEY`. Returns a safe canned answer if the key is missing, so your chat works instantly.

```ts
// server/anthropic.ts
import type { Request } from "express";

const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

export async function askClaude(prompt: string) {
  if (!ANTHROPIC_API_KEY) {
    // Safe fallback so chat works during setup
    return "Claude is not configured yet. Here’s a placeholder: I can assess your policy docs for SOC 2 gaps and recommend next steps once Anthropic API is connected.";
  }

  const resp = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "x-api-key": ANTHROPIC_API_KEY,
      "anthropic-version": "2023-06-01",
      "content-type": "application/json",
    },
    body: JSON.stringify({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 400,
      messages: [
        { role: "user", content: prompt }
      ],
      system: "You are a pragmatic compliance assistant. Keep answers concise and actionable.",
    }),
  });

  if (!resp.ok) {
    const t = await resp.text().catch(() => "");
    throw new Error(`Anthropic error: ${resp.status} ${t}`);
  }

  const data = await resp.json();
  // Anthropic messages API returns content array with text in .text
  const content = Array.isArray(data?.content) ? data.content : [];
  const firstText = content.find((c: any) => c.type === "text")?.text ?? "";
  return firstText || "No response content.";
}
```

---

# 3) `server/storage.ts` (Multer upload config)

> Stores files in `/uploads` which your repo already has. Creates DB row and audit log entry on route level shown in routes section.

```ts
// server/storage.ts
import multer from "multer";
import crypto from "crypto";
import path from "path";
import fs from "fs";

const uploadsDir = path.join(process.cwd(), "uploads");
if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

export const upload = multer({
  storage: multer.diskStorage({
    destination: (_req, _file, cb) => cb(null, uploadsDir),
    filename: (_req, file, cb) => {
      // keep original name + short hash for uniqueness
      const base = path.parse(file.originalname).name;
      const ext = path.extname(file.originalname);
      const stamp = Date.now().toString(36);
      cb(null, `${base}.${stamp}${ext}`.replace(/\s+/g, "_"));
    },
  }),
  limits: { fileSize: 25 * 1024 * 1024 }, // 25MB
  fileFilter: (_req, file, cb) => {
    // allow common doc/image/PDF; extend as needed
    const ok = /^(application\/pdf|image\/|text\/|application\/(msword|vnd.openxmlformats-officedocument|json|xml|zip))/.test(
      file.mimetype
    );
    cb(ok ? null : new Error("Unsupported file type"));
  },
});

// Utility to compute SHA-256 of a file (optional but useful)
export function sha256File(filePath: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash("sha256");
    const stream = fs.createReadStream(filePath);
    stream.on("error", reject);
    stream.on("data", (d) => hash.update(d));
    stream.on("end", () => resolve(hash.digest("hex")));
  });
}
```

---

# 4) `server/routes.ts` (new API routes)

> Adds:
>
> * `GET /api/chat/messages`
> * `POST /api/chat`
> * `POST /api/documents/upload`
> * `GET /api/summary`

Assumes you already have a Drizzle `db` instance exported from `server/db.ts`. If it’s named differently, just tweak the import. Also assumes you’re using Express app wiring in `server/index.ts`.

```ts
// server/routes.ts
import { Router } from "express";
import { and, desc, eq, sql } from "drizzle-orm";
import { db } from "./db";
import { askClaude } from "./anthropic";
import { upload, sha256File } from "./storage";
import {
  users, chatMessages, evidenceDocuments, auditLogs
} from "../shared/schema";

const router = Router();

// --- helpers ---
function getUserIdFromReq(req: any): string | null {
  // If you wired Replit auth or JWT, extract user id here.
  // For MVP, allow anonymous but keep null. Replace with real user id when available.
  return req.user?.id ?? null;
}

// --- Chat history ---
router.get("/api/chat/messages", async (req, res) => {
  try {
    const limit = Math.max(1, Math.min(100, parseInt(String(req.query.limit ?? "20"), 10)));
    const rows = await db
      .select()
      .from(chatMessages)
      .orderBy(desc(chatMessages.createdAt))
      .limit(limit);

    res.json(
      rows.map((r) => ({
        id: r.id,
        message: r.message,
        messageType: r.messageType,
        createdAt: r.createdAt,
      }))
    );
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// --- Send chat message (and get Claude reply) ---
router.post("/api/chat", async (req, res) => {
  try {
    const { message } = req.body ?? {};
    if (!message || typeof message !== "string") {
      return res.status(400).json({ error: "message is required" });
    }
    const userId = getUserIdFromReq(req);

    // Save user message
    const [userMsg] = await db.insert(chatMessages).values({
      userId,
      message,
      messageType: "user",
    }).returning();

    // Ask Claude (or fallback)
    const reply = await askClaude(
      `User question: ${message}\n\nProvide concise, actionable compliance guidance where possible.`
    );

    const [assistantMsg] = await db.insert(chatMessages).values({
      userId,
      message: reply,
      messageType: "assistant",
    }).returning();

    // audit
    await db.insert(auditLogs).values({
      userId,
      action: "chat",
      resourceType: "chat_messages",
      resourceId: assistantMsg.id,
      detail: { userMessageId: userMsg.id },
    });

    res.json({
      id: assistantMsg.id,
      message: assistantMsg.message,
      messageType: assistantMsg.messageType,
      createdAt: assistantMsg.createdAt,
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// --- Document upload ---
router.post("/api/documents/upload", upload.single("file"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: "file is required" });
    const userId = getUserIdFromReq(req);
    const hash = await sha256File(req.file.path);

    const [doc] = await db.insert(evidenceDocuments).values({
      userId,
      filename: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      storagePath: req.file.path,
      sha256: hash,
      version: 1,
      aiAnalysis: null,
    }).returning();

    await db.insert(auditLogs).values({
      userId,
      action: "upload",
      resourceType: "evidence_documents",
      resourceId: doc.id,
      detail: { filename: doc.filename, size: doc.size },
    });

    res.json({
      id: doc.id,
      filename: doc.filename,
      mimetype: doc.mimetype,
      size: doc.size,
      url: `/uploads/${encodeURIComponent(doc.storagePath.split("/").pop()!)}`, // see static serving below
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// --- Dashboard summary (placeholder logic that reads real tables) ---
router.get("/api/summary", async (_req, res) => {
  try {
    // Simple “real-feel” stats
    const [{ count: uploadsCount }] = await db.execute<{ count: number }>(
      sql`SELECT COUNT(*)::int AS count FROM ${evidenceDocuments}`
    );
    const [{ count: chatsCount }] = await db.execute<{ count: number }>(
      sql`SELECT COUNT(*)::int AS count FROM ${chatMessages}`
    );
    const recentActivity = await db
      .select()
      .from(auditLogs)
      .orderBy(desc(auditLogs.createdAt))
      .limit(8);

    // Fake a compliance percentage based on basic signals
    const baseline = 45;
    const bonus = Math.min(35, uploadsCount * 2 + Math.floor(chatsCount / 3));
    const compliancePercent = Math.max(0, Math.min(98, baseline + bonus));

    // Placeholder gaps (wire to frameworks later)
    const gaps = [
      { id: "gap-1", title: "Access Control Policy", severity: "high" },
      { id: "gap-2", title: "Vendor Risk Assessment", severity: "medium" },
      { id: "gap-3", title: "Incident Response Runbook", severity: "medium" },
    ];

    res.json({
      compliancePercent,
      gaps,
      stats: {
        uploads: uploadsCount,
        conversations: chatsCount,
      },
      recentActivity: recentActivity.map((a) => ({
        id: a.id,
        action: a.action,
        resourceType: a.resourceType,
        createdAt: a.createdAt,
      })),
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

export default router;
```

---

# 5) `server/index.ts` (ensure wiring + static `/uploads`)

> If you already mount a router, just add these lines. Otherwise, use this full file.

```ts
// server/index.ts
import express from "express";
import cors from "cors";
import path from "path";
import routes from "./routes";

const app = express();

app.use(cors());
app.use(express.json({ limit: "2mb" }));
app.use(express.urlencoded({ extended: true }));

// Serve uploaded files (read-only)
const publicUploadsDir = path.join(process.cwd(), "uploads");
app.use("/uploads", express.static(publicUploadsDir));

// API routes
app.use(routes);

// Health
app.get("/healthz", (_req, res) => res.json({ ok: true }));

// Start server (Replit PORT is set in .replit)
const PORT = process.env.PORT ? Number(process.env.PORT) : 5000;
app.listen(PORT, () => {
  console.log(`API listening on http://localhost:${PORT}`);
});
```

---

# 6) `server/db.ts` (example wiring if you need it)

> If you already have a `db.ts`, keep yours. If not, here’s a minimal Postgres Drizzle setup.

```ts
// server/db.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL, // e.g. postgresql://user:pass@host:5432/db
  ssl: process.env.PGSSL === "true" ? { rejectUnauthorized: false } : undefined,
});

export const db = drizzle(pool);
```

---

# 7) Client usage (already done)

Your chat component is already pointing to these endpoints and will “light up” with the server code in place . The router pages are already mounted, so `/api/summary` can feed the dashboard as soon as you bind it in the Dashboard page .

---

## Environment variables

Add these to your Replit Secrets (or `.env` in local dev):

```
DATABASE_URL=postgres://USER:PASS@HOST:5432/DBNAME
ANTHROPIC_API_KEY=sk-ant-...
PGSSL=false
```