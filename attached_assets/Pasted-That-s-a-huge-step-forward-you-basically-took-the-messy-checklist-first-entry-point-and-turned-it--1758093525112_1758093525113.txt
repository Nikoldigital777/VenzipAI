That‚Äôs a huge step forward ‚Äî you basically took the messy checklist-first entry point and turned it into a real SaaS-grade guided onboarding wizard with backend + schema support.
Let‚Äôs tighten it up so everything fits together smoothly, and you don‚Äôt hit schema/runtime errors.
‚úÖ What You‚Äôve Built
Frontend:
client/src/pages/onboarding.tsx ‚Üí 6-step flow (Welcome ‚Üí Company ‚Üí Frameworks ‚Üí Task Preview ‚Üí AI ‚Üí Summary).
Glassmorphic design + consistent palette.
Validation + progress indicator.
Backend:
server/routes.ts ‚Üí /api/onboarding/complete endpoint.
Auto task generation based on frameworks.
Schema:
Added companies, frameworks_companies.
Extended users with onboarding prefs.
Added companyId to tasks.
Migrations:
server/migrations/add-onboarding-tables.sql for the new tables.
üîÑ Next Refinements to Lock It Down
1. Schema Check
In shared/schema.ts, make sure these are defined:
export const companies = pgTable("companies", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: varchar("name", { length: 255 }),
  industry: varchar("industry", { length: 100 }),
  region: varchar("region", { length: 100 }),
  size: varchar("size", { length: 50 }),
  contactName: varchar("contact_name", { length: 100 }),
  contactEmail: varchar("contact_email", { length: 255 }),
  contactRole: varchar("contact_role", { length: 100 }),
  createdAt: timestamp("created_at").defaultNow(),
});

export const frameworks_companies = pgTable("frameworks_companies", {
  id: uuid("id").defaultRandom().primaryKey(),
  companyId: uuid("company_id").references(() => companies.id),
  frameworkId: uuid("framework_id").references(() => frameworks.id),
  createdAt: timestamp("created_at").defaultNow(),
});

// extend users
export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  passwordHash: varchar("password_hash", { length: 255 }),
  onboardingComplete: boolean("onboarding_complete").default(false),
  companyId: uuid("company_id").references(() => companies.id),
  // ‚Ä¶ keep other fields you had
});

// extend tasks
export const tasks = pgTable("tasks", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  status: varchar("status", { length: 50 }).default("not_started"),
  priority: varchar("priority", { length: 50 }).default("medium"),
  dueAt: timestamp("due_at"),
  frameworkId: uuid("framework_id").references(() => frameworks.id),
  companyId: uuid("company_id").references(() => companies.id), // new
  createdAt: timestamp("created_at").defaultNow(),
});
2. Migration Script (add-onboarding-tables.sql)
CREATE TABLE companies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255),
  industry VARCHAR(100),
  region VARCHAR(100),
  size VARCHAR(50),
  contact_name VARCHAR(100),
  contact_email VARCHAR(255),
  contact_role VARCHAR(100),
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE frameworks_companies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
  framework_id UUID REFERENCES frameworks(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT now()
);

ALTER TABLE users
  ADD COLUMN onboarding_complete BOOLEAN DEFAULT false,
  ADD COLUMN company_id UUID REFERENCES companies(id);

ALTER TABLE tasks
  ADD COLUMN company_id UUID REFERENCES companies(id);
3. Backend Endpoint (server/routes.ts)
app.post("/api/onboarding/complete", async (req, res) => {
  try {
    const { company, frameworks, userId } = req.body;

    // 1. Create company
    const [newCompany] = await db
      .insert(companies)
      .values(company)
      .returning();

    // 2. Link user ‚Üí company
    await db.update(users)
      .set({ companyId: newCompany.id, onboardingComplete: true })
      .where(eq(users.id, userId));

    // 3. Assign frameworks
    for (const fw of frameworks) {
      await db.insert(frameworks_companies).values({
        companyId: newCompany.id,
        frameworkId: fw.id,
      });

      // 4. Generate tasks from seeded controls
      const fwControls = await db
        .select()
        .from(controls)
        .where(eq(controls.frameworkId, fw.id));

      for (const c of fwControls) {
        await db.insert(tasks).values({
          title: c.title,
          description: c.description,
          frameworkId: fw.id,
          companyId: newCompany.id,
        });
      }
    }

    res.json({ success: true, companyId: newCompany.id });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Onboarding failed" });
  }
});
4. Frontend Final Step ‚Üí Dashboard
In onboarding.tsx, after hitting ‚ÄúFinish Setup‚Äù ‚Üí fetch('/api/onboarding/complete') ‚Üí then navigate('/dashboard').
This guarantees the flow: Landing ‚Üí Onboarding ‚Üí Dashboard (not checklist anymore).