Youâ€™ve nailed it: the onboarding flow itself is fine, but the schema/backend wiring is where the runtime error is coming from. Letâ€™s tighten this up systematically so the app runs cleanly.
ðŸ”§ Whatâ€™s Wrong Now
Schema relations in shared/schema.ts reference fields that donâ€™t exist (assignedToId, createdById, frameworkId werenâ€™t in your tasks table).
Company linkage wasnâ€™t consistently set up (companyId missing on some relations).
Onboarding endpoint in server/routes.ts was still mocky â†’ didnâ€™t use your actual storage/DB.
Duplicate helpers: you had more than one generateTasksForFramework floating around.
Storage layer missing methods â†’ causing evidence/tasks/eager-loading calls to break.
âœ… Step 1. Fix Schema Relations
In shared/schema.ts:
// Companies
export const companies = pgTable("companies", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: varchar("name", { length: 255 }),
  industry: varchar("industry", { length: 100 }),
  region: varchar("region", { length: 100 }),
  size: varchar("size", { length: 50 }),
  contactName: varchar("contact_name", { length: 100 }),
  contactEmail: varchar("contact_email", { length: 255 }),
  contactRole: varchar("contact_role", { length: 100 }),
  createdAt: timestamp("created_at").defaultNow(),
});

// Frameworks
export const frameworks = pgTable("frameworks", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: varchar("name", { length: 255 }),
  description: text("description"),
});

// Junction table
export const frameworksCompanies = pgTable("frameworks_companies", {
  id: uuid("id").defaultRandom().primaryKey(),
  companyId: uuid("company_id").references(() => companies.id),
  frameworkId: uuid("framework_id").references(() => frameworks.id),
  createdAt: timestamp("created_at").defaultNow(),
});

// Users
export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  passwordHash: varchar("password_hash", { length: 255 }),
  onboardingComplete: boolean("onboarding_complete").default(false),
  companyId: uuid("company_id").references(() => companies.id),
});

// Tasks
export const tasks = pgTable("tasks", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  status: varchar("status", { length: 50 }).default("not_started"),
  priority: varchar("priority", { length: 50 }).default("medium"),
  dueAt: timestamp("due_at"),
  frameworkId: uuid("framework_id").references(() => frameworks.id),
  companyId: uuid("company_id").references(() => companies.id),
  createdAt: timestamp("created_at").defaultNow(),
});
ðŸ‘‰ Now relations line up with actual fields.
âœ… Step 2. Fix Backend Endpoint
In server/routes.ts:
app.post("/api/onboarding/complete", async (req, res) => {
  try {
    const { company, frameworks, userId } = req.body;

    // 1. Insert company
    const [newCompany] = await db.insert(companies).values(company).returning();

    // 2. Update user
    await db.update(users)
      .set({ companyId: newCompany.id, onboardingComplete: true })
      .where(eq(users.id, userId));

    // 3. Assign frameworks + seed tasks
    for (const fw of frameworks) {
      await db.insert(frameworksCompanies).values({
        companyId: newCompany.id,
        frameworkId: fw.id,
      });

      // Generate framework-specific tasks
      const controls = await db
        .select()
        .from(controls) // make sure you seeded framework controls in seedComplianceData.ts
        .where(eq(controls.frameworkId, fw.id));

      for (const c of controls) {
        await db.insert(tasks).values({
          title: c.title,
          description: c.description,
          frameworkId: fw.id,
          companyId: newCompany.id,
        });
      }
    }

    res.json({ success: true, companyId: newCompany.id });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Onboarding failed" });
  }
});
âœ… Step 3. Remove Duplicates
Keep one generateTasksForFramework in server/storage.ts.
Remove any duplicates hiding in utils.ts or inline in routes.ts.
âœ… Step 4. Add Storage Helpers
In server/storage.ts:
export async function createCompany(data) {
  const [company] = await db.insert(companies).values(data).returning();
  return company;
}

export async function assignFrameworkToCompany(companyId, frameworkId) {
  return db.insert(frameworksCompanies).values({ companyId, frameworkId });
}

export async function createTasksFromFramework(companyId, frameworkId) {
  const fwControls = await db
    .select()
    .from(controls)
    .where(eq(controls.frameworkId, frameworkId));

  for (const c of fwControls) {
    await db.insert(tasks).values({
      title: c.title,
      description: c.description,
      frameworkId,
      companyId,
    });
  }
}
âœ… Step 5. Migration Adjustments
Make sure your add-onboarding-tables.sql matches the schema fixes:
Drop ghost columns (assignedToId, createdById).
Add company_id to tasks and users.
Ensure foreign keys line up (framework_id, company_id).
ðŸš€ With This
Your onboarding flow actually persists companies + frameworks + tasks.
Runtime error from Drizzle relations goes away.
Duplicate helpers cleaned up.
Frontend Task Preview will show real seeded controls instead of placeholders.